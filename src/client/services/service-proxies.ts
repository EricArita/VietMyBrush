/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.2.0 (NJsonSchema v10.1.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class ServiceProxy {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : 'http://localhost:3000/api';
  }

  /**
   * Register / log in user
   * @param body (optional)
   * @return successful operation
   */
  registerUser(body: any | undefined): Promise<User> {
    let url_ = this.baseUrl + '/auth';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRegisterUser(_response);
    });
  }

  protected processRegisterUser(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  /**
   * Send reset password code
   * @param body (optional)
   * @return successful operation
   */
  sendResetPasswordCode(body: any | undefined): Promise<SendResetPasswordCodeResponse> {
    let url_ = this.baseUrl + '/auth/send-reset-password-code';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSendResetPasswordCode(_response);
    });
  }

  protected processSendResetPasswordCode(response: Response): Promise<SendResetPasswordCodeResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <SendResetPasswordCodeResponse>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 =
          _responseText === '' ? null : <SendResetPasswordCodeResponse>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<SendResetPasswordCodeResponse>(<any>null);
  }

  /**
   * Check password reset code
   * @param body (optional)
   * @return successful operation
   */
  checkPasswordResetCode(body: any | undefined): Promise<CheckPasswordResetCodeResponse> {
    let url_ = this.baseUrl + '/auth/check-password-code';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCheckPasswordResetCode(_response);
    });
  }

  protected processCheckPasswordResetCode(response: Response): Promise<CheckPasswordResetCodeResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : <CheckPasswordResetCodeResponse>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 =
          _responseText === ''
            ? null
            : <CheckPasswordResetCodeResponse>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<CheckPasswordResetCodeResponse>(<any>null);
  }

  /**
   * Reset password
   * @param body (optional)
   * @return successful operation
   */
  reset_Password(body: any | undefined): Promise<ResetPasswordResponse> {
    let url_ = this.baseUrl + '/auth/reset-password';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processReset_Password(_response);
    });
  }

  protected processReset_Password(response: Response): Promise<ResetPasswordResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <ResetPasswordResponse>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 =
          _responseText === '' ? null : <ResetPasswordResponse>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<ResetPasswordResponse>(<any>null);
  }

  /**
   * Log out
   * @param body (optional)
   * @return successful operation
   */
  logOut(body: any | undefined): Promise<LogOutResponse> {
    let url_ = this.baseUrl + '/auth/log-out';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLogOut(_response);
    });
  }

  protected processLogOut(response: Response): Promise<LogOutResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <LogOutResponse>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <LogOutResponse>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<LogOutResponse>(<any>null);
  }

  /**
   * Find permissions list of all modules
   * @return successful operation
   */
  findPermissions(): Promise<FindPermissionsResult> {
    let url_ = this.baseUrl + '/permissions';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindPermissions(_response);
    });
  }

  protected processFindPermissions(response: Response): Promise<FindPermissionsResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <FindPermissionsResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return throwException('successful operation', status, _responseText, _headers);
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindPermissionsResult>(<any>null);
  }

  /**
   * Check role name exist
   * @param roleName roleName
   * @return successful operation
   */
  checkRoleNameExist(roleName: string): Promise<CheckRoleNameExistResult> {
    let url_ = this.baseUrl + '/roles/check-name-exist/{roleName}';
    if (roleName === undefined || roleName === null) throw new Error("The parameter 'roleName' must be defined.");
    url_ = url_.replace('{roleName}', encodeURIComponent('' + roleName));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCheckRoleNameExist(_response);
    });
  }

  protected processCheckRoleNameExist(response: Response): Promise<CheckRoleNameExistResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <CheckRoleNameExistResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<CheckRoleNameExistResult>(<any>null);
  }

  /**
   * get role by name
   * @param roleName roleName
   * @return successful operation
   */
  getRoleByName(roleName: string): Promise<Role> {
    let url_ = this.baseUrl + '/roles/get-by-name/{roleName}';
    if (roleName === undefined || roleName === null) throw new Error("The parameter 'roleName' must be defined.");
    url_ = url_.replace('{roleName}', encodeURIComponent('' + roleName));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetRoleByName(_response);
    });
  }

  protected processGetRoleByName(response: Response): Promise<Role> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Role>(<any>null);
  }

  /**
   * Find all roles
   * @return successful operation
   */
  getAllRoles(): Promise<GetAllRolesResult> {
    let url_ = this.baseUrl + '/roles/get-all';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllRoles(_response);
    });
  }

  protected processGetAllRoles(response: Response): Promise<GetAllRolesResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <GetAllRolesResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<GetAllRolesResult>(<any>null);
  }

  /**
   * Find role by id
   * @param roleId roleId
   * @return successful operation
   */
  findRoleById(roleId: string): Promise<Role> {
    let url_ = this.baseUrl + '/roles/{roleId}';
    if (roleId === undefined || roleId === null) throw new Error("The parameter 'roleId' must be defined.");
    url_ = url_.replace('{roleId}', encodeURIComponent('' + roleId));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindRoleById(_response);
    });
  }

  protected processFindRoleById(response: Response): Promise<Role> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Role>(<any>null);
  }

  /**
   * Update role
   * @param roleId roleId
   * @param body (optional)
   * @return successful operation
   */
  updateRole(roleId: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/roles/{roleId}';
    if (roleId === undefined || roleId === null) throw new Error("The parameter 'roleId' must be defined.");
    url_ = url_.replace('{roleId}', encodeURIComponent('' + roleId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateRole(_response);
    });
  }

  protected processUpdateRole(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Find roles
   * @param search (optional) search
   * @param permissions (optional) filter by permissions
   * @param first number of records returned
   * @param sortBy sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @return successful operation
   */
  findRoles(
    search: string | undefined,
    permissions: string[] | undefined,
    first: number,
    sortBy: string,
    before: string | undefined,
    after: string | undefined,
  ): Promise<FindRolesResult> {
    let url_ = this.baseUrl + '/roles?';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (permissions === null) throw new Error("The parameter 'permissions' cannot be null.");
    else if (permissions !== undefined)
      permissions &&
        permissions.forEach((item) => {
          url_ += 'permissions=' + encodeURIComponent('' + item) + '&';
        });
    if (first === undefined || first === null)
      throw new Error("The parameter 'first' must be defined and cannot be null.");
    else url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === undefined || sortBy === null)
      throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
    else url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindRoles(_response);
    });
  }

  protected processFindRoles(response: Response): Promise<FindRolesResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FindRolesResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindRolesResult>(<any>null);
  }

  /**
   * Create role
   * @param body (optional)
   * @return successful operation
   */
  createRole(body: any | undefined): Promise<Role> {
    let url_ = this.baseUrl + '/roles';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateRole(_response);
    });
  }

  protected processCreateRole(response: Response): Promise<Role> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <Role>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Role>(<any>null);
  }

  /**
   * Find profile
   * @param userId userId
   * @return successful operation
   */
  findProfile(userId: string): Promise<User> {
    let url_ = this.baseUrl + '/profile/{userId}';
    if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindProfile(_response);
    });
  }

  protected processFindProfile(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  /**
   * Update profile
   * @param userId userId
   * @param body (optional)
   * @return successful operation
   */
  updateProfile(userId: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/profile/{userId}';
    if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateProfile(_response);
    });
  }

  protected processUpdateProfile(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Check email exist
   * @param email email
   * @return successful operation
   */
  checkEmailExist(email: string): Promise<CheckEmailExistResult> {
    let url_ = this.baseUrl + '/users/check-email-exist/{email}';
    if (email === undefined || email === null) throw new Error("The parameter 'email' must be defined.");
    url_ = url_.replace('{email}', encodeURIComponent('' + email));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCheckEmailExist(_response);
    });
  }

  protected processCheckEmailExist(response: Response): Promise<CheckEmailExistResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <CheckEmailExistResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<CheckEmailExistResult>(<any>null);
  }

  /**
   * Get user analytic
   * @param id user id
   * @return successful operation
   */
  getUserAnalytic(id: string): Promise<Anonymous> {
    let url_ = this.baseUrl + '/users/analytic/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetUserAnalytic(_response);
    });
  }

  protected processGetUserAnalytic(response: Response): Promise<Anonymous> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Anonymous>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Anonymous>(<any>null);
  }

  /**
   * Get user by apple id
   * @param id user id
   * @return successful operation
   */
  getUserByAppleId(id: string): Promise<User> {
    let url_ = this.baseUrl + '/users/get-by-apple-id/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetUserByAppleId(_response);
    });
  }

  protected processGetUserByAppleId(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  /**
   * Find users
   * @param search (optional) search
   * @param roles (optional) filter by roles
   * @param filter (optional) custom filter
   * @param first number of records returned
   * @param sortBy sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @param availability (optional) availability filter
   * @param specificTime (optional) specific time filter
   * @return successful operation
   */
  findUsers(
    search: string | undefined,
    roles: string[] | undefined,
    filter: any[] | undefined,
    first: number,
    sortBy: string,
    before: string | undefined,
    after: string | undefined,
    availability: Availability | undefined,
    specificTime: number[] | undefined,
  ): Promise<FindUsersResult> {
    let url_ = this.baseUrl + '/users?';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (roles === null) throw new Error("The parameter 'roles' cannot be null.");
    else if (roles !== undefined)
      roles &&
        roles.forEach((item) => {
          url_ += 'roles=' + encodeURIComponent('' + item) + '&';
        });
    if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
    else if (filter !== undefined)
      filter &&
        filter.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'filter[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (first === undefined || first === null)
      throw new Error("The parameter 'first' must be defined and cannot be null.");
    else url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === undefined || sortBy === null)
      throw new Error("The parameter 'sortBy' must be defined and cannot be null.");
    else url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    if (availability === null) throw new Error("The parameter 'availability' cannot be null.");
    else if (availability !== undefined) url_ += 'availability=' + encodeURIComponent('' + availability) + '&';
    if (specificTime === null) throw new Error("The parameter 'specificTime' cannot be null.");
    else if (specificTime !== undefined)
      specificTime &&
        specificTime.forEach((item) => {
          url_ += 'specificTime=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindUsers(_response);
    });
  }

  protected processFindUsers(response: Response): Promise<FindUsersResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FindUsersResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindUsersResult>(<any>null);
  }

  /**
   * Create user
   * @param body (optional)
   * @return successful operation
   */
  createUser(body: any | undefined): Promise<User> {
    let url_ = this.baseUrl + '/users';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateUser(_response);
    });
  }

  protected processCreateUser(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  /**
   * Get all users
   * @return successful operation
   */
  getAllUsers(): Promise<FindAllUsersResult> {
    let url_ = this.baseUrl + '/users/get-all-users';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllUsers(_response);
    });
  }

  protected processGetAllUsers(response: Response): Promise<FindAllUsersResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FindAllUsersResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindAllUsersResult>(<any>null);
  }

  /**
   * Find permissions by user id
   * @param id userId
   * @return successful operation
   */
  getPermissions(id: string): Promise<PermissionsResult> {
    let url_ = this.baseUrl + '/users/get-permissions/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPermissions(_response);
    });
  }

  protected processGetPermissions(response: Response): Promise<PermissionsResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <PermissionsResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<PermissionsResult>(<any>null);
  }

  /**
   * Find user by id
   * @param userId userId
   * @return successful operation
   */
  findUserById(userId: string): Promise<User> {
    let url_ = this.baseUrl + '/users/{userId}';
    if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindUserById(_response);
    });
  }

  protected processFindUserById(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  /**
   * Update user
   * @param userId userId
   * @param body (optional)
   * @return successful operation
   */
  updateUser(userId: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/users/{userId}';
    if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateUser(_response);
    });
  }

  protected processUpdateUser(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get all Career
   * @param operation (optional) operation
   * @param search (optional) search
   * @param filter (optional) filters
   * @param first (optional) number of records returned
   * @param sortBy (optional) sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @return successful operation
   */
  career(
    operation: string | undefined,
    search: string | undefined,
    filter: any[] | undefined,
    first: number | undefined,
    sortBy: string | undefined,
    before: string | undefined,
    after: string | undefined,
  ): Promise<FindCareerResult> {
    let url_ = this.baseUrl + '/career?';
    if (operation === null) throw new Error("The parameter 'operation' cannot be null.");
    else if (operation !== undefined) url_ += 'operation=' + encodeURIComponent('' + operation) + '&';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
    else if (filter !== undefined)
      filter &&
        filter.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'filter[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (first === null) throw new Error("The parameter 'first' cannot be null.");
    else if (first !== undefined) url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === null) throw new Error("The parameter 'sortBy' cannot be null.");
    else if (sortBy !== undefined) url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCareer(_response);
    });
  }

  protected processCareer(response: Response): Promise<FindCareerResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FindCareerResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindCareerResult>(<any>null);
  }

  /**
   * Create New Career
   * @param body (optional)
   * @return successful operation
   */
  createCareer(body: any | undefined): Promise<Career> {
    let url_ = this.baseUrl + '/career';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateCareer(_response);
    });
  }

  protected processCreateCareer(response: Response): Promise<Career> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Career>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <Career>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Career>(<any>null);
  }

  /**
   * Get Single Career
   * @param id id
   * @return successful operation
   */
  getSingleCareer(id: string): Promise<Career> {
    let url_ = this.baseUrl + '/career/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSingleCareer(_response);
    });
  }

  protected processGetSingleCareer(response: Response): Promise<Career> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Career>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Career>(<any>null);
  }

  /**
   * Update Career
   * @param id id
   * @param body (optional)
   * @return successful operation
   */
  updateCareer(id: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/career/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateCareer(_response);
    });
  }

  protected processUpdateCareer(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get all Career
   * @param operation (optional) operation
   * @param search (optional) search
   * @param filter (optional) filters
   * @param first (optional) number of records returned
   * @param sortBy (optional) sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @return successful operation
   */
  getAllCareerMatrix(
    operation: string | undefined,
    search: string | undefined,
    filter: any[] | undefined,
    first: number | undefined,
    sortBy: string | undefined,
    before: string | undefined,
    after: string | undefined,
  ): Promise<FindCareerMatrixResult> {
    let url_ = this.baseUrl + '/careerMatrix?';
    if (operation === null) throw new Error("The parameter 'operation' cannot be null.");
    else if (operation !== undefined) url_ += 'operation=' + encodeURIComponent('' + operation) + '&';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
    else if (filter !== undefined)
      filter &&
        filter.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'filter[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (first === null) throw new Error("The parameter 'first' cannot be null.");
    else if (first !== undefined) url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === null) throw new Error("The parameter 'sortBy' cannot be null.");
    else if (sortBy !== undefined) url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllCareerMatrix(_response);
    });
  }

  protected processGetAllCareerMatrix(response: Response): Promise<FindCareerMatrixResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <FindCareerMatrixResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindCareerMatrixResult>(<any>null);
  }

  /**
   * Create New Career Matrix
   * @param body (optional)
   * @return successful operation
   */
  createCareerMatrix(body: any | undefined): Promise<CareerMatrix> {
    let url_ = this.baseUrl + '/careerMatrix';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateCareerMatrix(_response);
    });
  }

  protected processCreateCareerMatrix(response: Response): Promise<CareerMatrix> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <CareerMatrix>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <CareerMatrix>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<CareerMatrix>(<any>null);
  }

  /**
   * Update Career Matrix
   * @param id id
   * @param body (optional)
   * @return successful operation
   */
  updateCareerMatrix(id: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/careerMatrix/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateCareerMatrix(_response);
    });
  }

  protected processUpdateCareerMatrix(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Find all notification
   * @param operation (optional) operation
   * @param search (optional) search
   * @param filter (optional) filters
   * @param first (optional) number of records returned
   * @param sortBy (optional) sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @return successful operation
   */
  findNotifications(
    operation: string | undefined,
    search: string | undefined,
    filter: any[] | undefined,
    first: number | undefined,
    sortBy: string | undefined,
    before: string | undefined,
    after: string | undefined,
  ): Promise<FindNotificationsResult> {
    let url_ = this.baseUrl + '/notification?';
    if (operation === null) throw new Error("The parameter 'operation' cannot be null.");
    else if (operation !== undefined) url_ += 'operation=' + encodeURIComponent('' + operation) + '&';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
    else if (filter !== undefined)
      filter &&
        filter.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'filter[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (first === null) throw new Error("The parameter 'first' cannot be null.");
    else if (first !== undefined) url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === null) throw new Error("The parameter 'sortBy' cannot be null.");
    else if (sortBy !== undefined) url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindNotifications(_response);
    });
  }

  protected processFindNotifications(response: Response): Promise<FindNotificationsResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <FindNotificationsResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindNotificationsResult>(<any>null);
  }

  /**
   * Create Notification
   * @param body (optional)
   * @return successful operation
   */
  createNotification(body: any | undefined): Promise<Notification> {
    let url_ = this.baseUrl + '/notification';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateNotification(_response);
    });
  }

  protected processCreateNotification(response: Response): Promise<Notification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Notification>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <Notification>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Notification>(<any>null);
  }

  /**
   * Find notification by id
   * @param notificationId notificationId
   * @return successful operation
   */
  findNotificationById(notificationId: string): Promise<Notification> {
    let url_ = this.baseUrl + '/notification/{notificationId}';
    if (notificationId === undefined || notificationId === null)
      throw new Error("The parameter 'notificationId' must be defined.");
    url_ = url_.replace('{notificationId}', encodeURIComponent('' + notificationId));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processFindNotificationById(_response);
    });
  }

  protected processFindNotificationById(response: Response): Promise<Notification> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Notification>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Notification>(<any>null);
  }

  /**
   * Update notification
   * @param notificationId notificationId
   * @param body (optional)
   * @return successful operation
   */
  updateNotification(notificationId: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/notification/{notificationId}';
    if (notificationId === undefined || notificationId === null)
      throw new Error("The parameter 'notificationId' must be defined.");
    url_ = url_.replace('{notificationId}', encodeURIComponent('' + notificationId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateNotification(_response);
    });
  }

  protected processUpdateNotification(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Delete notification
   * @param notificationId notificationId
   * @return successful operation
   */
  deleteNotification(notificationId: string): Promise<void> {
    let url_ = this.baseUrl + '/notification/{notificationId}';
    if (notificationId === undefined || notificationId === null)
      throw new Error("The parameter 'notificationId' must be defined.");
    url_ = url_.replace('{notificationId}', encodeURIComponent('' + notificationId));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'DELETE',
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteNotification(_response);
    });
  }

  protected processDeleteNotification(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get all Test Packs
   * @param operation (optional) operation
   * @param search (optional) search
   * @param filter (optional) filters
   * @param first (optional) number of records returned
   * @param sortBy (optional) sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @return successful operation
   */
  testPack(
    operation: string | undefined,
    search: string | undefined,
    filter: any[] | undefined,
    first: number | undefined,
    sortBy: string | undefined,
    before: string | undefined,
    after: string | undefined,
  ): Promise<FindTestPackResult> {
    let url_ = this.baseUrl + '/testPack?';
    if (operation === null) throw new Error("The parameter 'operation' cannot be null.");
    else if (operation !== undefined) url_ += 'operation=' + encodeURIComponent('' + operation) + '&';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
    else if (filter !== undefined)
      filter &&
        filter.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'filter[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (first === null) throw new Error("The parameter 'first' cannot be null.");
    else if (first !== undefined) url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === null) throw new Error("The parameter 'sortBy' cannot be null.");
    else if (sortBy !== undefined) url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processTestPack(_response);
    });
  }

  protected processTestPack(response: Response): Promise<FindTestPackResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FindTestPackResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindTestPackResult>(<any>null);
  }

  /**
   * Create Test Pack
   * @param body (optional)
   * @return successful operation
   */
  createTestPack(body: any | undefined): Promise<TestPack> {
    let url_ = this.baseUrl + '/testPack';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateTestPack(_response);
    });
  }

  protected processCreateTestPack(response: Response): Promise<TestPack> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <TestPack>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <TestPack>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<TestPack>(<any>null);
  }

  /**
   * Get Test Pack
   * @param id id
   * @return successful operation
   */
  getSingleTestPack(id: string): Promise<TestPack> {
    let url_ = this.baseUrl + '/testpack/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSingleTestPack(_response);
    });
  }

  protected processGetSingleTestPack(response: Response): Promise<TestPack> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <TestPack>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<TestPack>(<any>null);
  }

  /**
   * Update Test Pack
   * @param id id
   * @param body (optional)
   * @return successful operation
   */
  updateTestPack(id: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/testpack/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateTestPack(_response);
    });
  }

  protected processUpdateTestPack(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get all Section By Pack
   * @param operation (optional) operation
   * @param search (optional) search
   * @param filter (optional) filters
   * @param first (optional) number of records returned
   * @param sortBy (optional) sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @return successful operation
   */
  sectionByPack(
    operation: string | undefined,
    search: string | undefined,
    filter: any[] | undefined,
    first: number | undefined,
    sortBy: string | undefined,
    before: string | undefined,
    after: string | undefined,
  ): Promise<FindSectionResult> {
    let url_ = this.baseUrl + '/sectionByPack?';
    if (operation === null) throw new Error("The parameter 'operation' cannot be null.");
    else if (operation !== undefined) url_ += 'operation=' + encodeURIComponent('' + operation) + '&';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
    else if (filter !== undefined)
      filter &&
        filter.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'filter[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (first === null) throw new Error("The parameter 'first' cannot be null.");
    else if (first !== undefined) url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === null) throw new Error("The parameter 'sortBy' cannot be null.");
    else if (sortBy !== undefined) url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSectionByPack(_response);
    });
  }

  protected processSectionByPack(response: Response): Promise<FindSectionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FindSectionResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindSectionResult>(<any>null);
  }

  /**
   * Create Section Pack
   * @param body (optional)
   * @return successful operation
   */
  createSectionByPack(body: any | undefined): Promise<SectionByPack> {
    let url_ = this.baseUrl + '/sectionByPack';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateSectionByPack(_response);
    });
  }

  protected processCreateSectionByPack(response: Response): Promise<SectionByPack> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <SectionByPack>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <SectionByPack>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<SectionByPack>(<any>null);
  }

  /**
   * Get Test Pack
   * @param id id
   * @return successful operation
   */
  getSingleSection(id: string): Promise<SectionByPack> {
    let url_ = this.baseUrl + '/sectionByPack/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSingleSection(_response);
    });
  }

  protected processGetSingleSection(response: Response): Promise<SectionByPack> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <SectionByPack>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<SectionByPack>(<any>null);
  }

  /**
   * Update Section By Pack
   * @param id id
   * @param body (optional)
   * @return successful operation
   */
  updateSectionByPack(id: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/sectionByPack/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateSectionByPack(_response);
    });
  }

  protected processUpdateSectionByPack(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get all Personality By Pack
   * @param operation (optional) operation
   * @param search (optional) search
   * @param filter (optional) filters
   * @param first (optional) number of records returned
   * @param sortBy (optional) sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @return successful operation
   */
  personalityByPack(
    operation: string | undefined,
    search: string | undefined,
    filter: any[] | undefined,
    first: number | undefined,
    sortBy: string | undefined,
    before: string | undefined,
    after: string | undefined,
  ): Promise<FindPersonalityResult> {
    let url_ = this.baseUrl + '/personalityByPack?';
    if (operation === null) throw new Error("The parameter 'operation' cannot be null.");
    else if (operation !== undefined) url_ += 'operation=' + encodeURIComponent('' + operation) + '&';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
    else if (filter !== undefined)
      filter &&
        filter.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'filter[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (first === null) throw new Error("The parameter 'first' cannot be null.");
    else if (first !== undefined) url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === null) throw new Error("The parameter 'sortBy' cannot be null.");
    else if (sortBy !== undefined) url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPersonalityByPack(_response);
    });
  }

  protected processPersonalityByPack(response: Response): Promise<FindPersonalityResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <FindPersonalityResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindPersonalityResult>(<any>null);
  }

  /**
   * Create Personaliy By Pack
   * @param body (optional)
   * @return successful operation
   */
  createPersonality(body: any | undefined): Promise<PersonalityByPack> {
    let url_ = this.baseUrl + '/personalityByPack';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreatePersonality(_response);
    });
  }

  protected processCreatePersonality(response: Response): Promise<PersonalityByPack> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <PersonalityByPack>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <PersonalityByPack>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<PersonalityByPack>(<any>null);
  }

  /**
   * Get Personality Pack
   * @param id id
   * @return successful operation
   */
  getSinglePersonalityByPack(id: string): Promise<PersonalityByPack> {
    let url_ = this.baseUrl + '/personalityByPack/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSinglePersonalityByPack(_response);
    });
  }

  protected processGetSinglePersonalityByPack(response: Response): Promise<PersonalityByPack> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <PersonalityByPack>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<PersonalityByPack>(<any>null);
  }

  /**
   * Update Personality By Pack
   * @param id id
   * @param body (optional)
   * @return successful operation
   */
  updatePersonalityByPack(id: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/personalityByPack/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdatePersonalityByPack(_response);
    });
  }

  protected processUpdatePersonalityByPack(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Find All Questions
   * @param operation (optional) operation
   * @param search (optional) search
   * @param filter (optional) filters
   * @param first (optional) number of records returned
   * @param sortBy (optional) sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @return successful operation
   */
  getAllQuestions(
    operation: string | undefined,
    search: string | undefined,
    filter: any[] | undefined,
    first: number | undefined,
    sortBy: string | undefined,
    before: string | undefined,
    after: string | undefined,
  ): Promise<FindQuestionResult> {
    let url_ = this.baseUrl + '/question?';
    if (operation === null) throw new Error("The parameter 'operation' cannot be null.");
    else if (operation !== undefined) url_ += 'operation=' + encodeURIComponent('' + operation) + '&';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
    else if (filter !== undefined)
      filter &&
        filter.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'filter[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (first === null) throw new Error("The parameter 'first' cannot be null.");
    else if (first !== undefined) url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === null) throw new Error("The parameter 'sortBy' cannot be null.");
    else if (sortBy !== undefined) url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllQuestions(_response);
    });
  }

  protected processGetAllQuestions(response: Response): Promise<FindQuestionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FindQuestionResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindQuestionResult>(<any>null);
  }

  /**
   * Create Question
   * @param body (optional)
   * @return successful operation
   */
  createQuestion(body: any | undefined): Promise<Question> {
    let url_ = this.baseUrl + '/question';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateQuestion(_response);
    });
  }

  protected processCreateQuestion(response: Response): Promise<Question> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Question>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <Question>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Question>(<any>null);
  }

  /**
   * Get Single Question
   * @param id id
   * @return successful operation
   */
  getSingleQuestion(id: string): Promise<Question> {
    let url_ = this.baseUrl + '/question/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSingleQuestion(_response);
    });
  }

  protected processGetSingleQuestion(response: Response): Promise<Question> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Question>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Question>(<any>null);
  }

  /**
   * Update Single Question
   * @param id questionId
   * @param body (optional)
   * @return successful operation
   */
  updateQuestion(id: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/question/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateQuestion(_response);
    });
  }

  protected processUpdateQuestion(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Find All Answer
   * @param operation (optional) operation
   * @param search (optional) search
   * @param filter (optional) filters
   * @param first (optional) number of records returned
   * @param sortBy (optional) sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @return successful operation
   */
  getAllAnswer(
    operation: string | undefined,
    search: string | undefined,
    filter: any[] | undefined,
    first: number | undefined,
    sortBy: string | undefined,
    before: string | undefined,
    after: string | undefined,
  ): Promise<FindAnswerResult> {
    let url_ = this.baseUrl + '/answer?';
    if (operation === null) throw new Error("The parameter 'operation' cannot be null.");
    else if (operation !== undefined) url_ += 'operation=' + encodeURIComponent('' + operation) + '&';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
    else if (filter !== undefined)
      filter &&
        filter.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'filter[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (first === null) throw new Error("The parameter 'first' cannot be null.");
    else if (first !== undefined) url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === null) throw new Error("The parameter 'sortBy' cannot be null.");
    else if (sortBy !== undefined) url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllAnswer(_response);
    });
  }

  protected processGetAllAnswer(response: Response): Promise<FindAnswerResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <FindAnswerResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindAnswerResult>(<any>null);
  }

  /**
   * Create Answer
   * @param body (optional)
   * @return successful operation
   */
  createAnswer(body: any | undefined): Promise<Answer> {
    let url_ = this.baseUrl + '/answer';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateAnswer(_response);
    });
  }

  protected processCreateAnswer(response: Response): Promise<Answer> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Answer>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <Answer>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Answer>(<any>null);
  }

  /**
   * Get Single Answer
   * @param id id
   * @return successful operation
   */
  getSingleAnswer(id: string): Promise<Answer> {
    let url_ = this.baseUrl + '/answer/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetSingleAnswer(_response);
    });
  }

  protected processGetSingleAnswer(response: Response): Promise<Answer> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Answer>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Answer>(<any>null);
  }

  /**
   * Update Single Answer
   * @param id answerId
   * @param body (optional)
   * @return successful operation
   */
  updateAnswer(id: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/answer/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateAnswer(_response);
    });
  }

  protected processUpdateAnswer(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get All Answer Detail By Attendance
   * @param operation (optional) operation
   * @param search (optional) search
   * @param filter (optional) filters
   * @param first (optional) number of records returned
   * @param sortBy (optional) sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @return successful operation
   */
  getAllAnswerDetail(
    operation: string | undefined,
    search: string | undefined,
    filter: any[] | undefined,
    first: number | undefined,
    sortBy: string | undefined,
    before: string | undefined,
    after: string | undefined,
  ): Promise<FindAnswerDetailResult> {
    let url_ = this.baseUrl + '/answerDetail?';
    if (operation === null) throw new Error("The parameter 'operation' cannot be null.");
    else if (operation !== undefined) url_ += 'operation=' + encodeURIComponent('' + operation) + '&';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
    else if (filter !== undefined)
      filter &&
        filter.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'filter[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (first === null) throw new Error("The parameter 'first' cannot be null.");
    else if (first !== undefined) url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === null) throw new Error("The parameter 'sortBy' cannot be null.");
    else if (sortBy !== undefined) url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllAnswerDetail(_response);
    });
  }

  protected processGetAllAnswerDetail(response: Response): Promise<FindAnswerDetailResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <FindAnswerDetailResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindAnswerDetailResult>(<any>null);
  }

  /**
   * Create Answer Detail By Attendance
   * @param body (optional)
   * @return successful operation
   */
  createAnswerByAttendance(body: any | undefined): Promise<AnswerDetailByAttendance> {
    let url_ = this.baseUrl + '/answerDetail';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateAnswerByAttendance(_response);
    });
  }

  protected processCreateAnswerByAttendance(response: Response): Promise<AnswerDetailByAttendance> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <AnswerDetailByAttendance>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 =
          _responseText === '' ? null : <AnswerDetailByAttendance>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<AnswerDetailByAttendance>(<any>null);
  }

  /**
   * Get Detail Answer
   * @param id id
   * @return successful operation
   */
  getDetailAnswer(id: string): Promise<AnswerDetailByAttendance> {
    let url_ = this.baseUrl + '/answerDetail/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetDetailAnswer(_response);
    });
  }

  protected processGetDetailAnswer(response: Response): Promise<AnswerDetailByAttendance> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <AnswerDetailByAttendance>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<AnswerDetailByAttendance>(<any>null);
  }

  /**
   * Update Detail Answer
   * @param id answerId
   * @param body (optional)
   * @return successful operation
   */
  updateDetailAnswer(id: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/answerDetail/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateDetailAnswer(_response);
    });
  }

  protected processUpdateDetailAnswer(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get All Personality Detail By Attendance
   * @param operation (optional) operation
   * @param search (optional) search
   * @param filter (optional) filters
   * @param first (optional) number of records returned
   * @param sortBy (optional) sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @return successful operation
   */
  getAllPersonalityByAttendance(
    operation: string | undefined,
    search: string | undefined,
    filter: any[] | undefined,
    first: number | undefined,
    sortBy: string | undefined,
    before: string | undefined,
    after: string | undefined,
  ): Promise<FindPersonalityByAttendanceDetailResult> {
    let url_ = this.baseUrl + '/personalityByAttendance?';
    if (operation === null) throw new Error("The parameter 'operation' cannot be null.");
    else if (operation !== undefined) url_ += 'operation=' + encodeURIComponent('' + operation) + '&';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
    else if (filter !== undefined)
      filter &&
        filter.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'filter[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (first === null) throw new Error("The parameter 'first' cannot be null.");
    else if (first !== undefined) url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === null) throw new Error("The parameter 'sortBy' cannot be null.");
    else if (sortBy !== undefined) url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllPersonalityByAttendance(_response);
    });
  }

  protected processGetAllPersonalityByAttendance(response: Response): Promise<FindPersonalityByAttendanceDetailResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === ''
            ? null
            : <FindPersonalityByAttendanceDetailResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindPersonalityByAttendanceDetailResult>(<any>null);
  }

  /**
   * Create Personality Detail By Attendance
   * @param body (optional)
   * @return successful operation
   */
  createPersonalityByAttendance(body: any | undefined): Promise<PersonalityByAttendance> {
    let url_ = this.baseUrl + '/personalityByAttendance';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreatePersonalityByAttendance(_response);
    });
  }

  protected processCreatePersonalityByAttendance(response: Response): Promise<PersonalityByAttendance> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <PersonalityByAttendance>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 =
          _responseText === '' ? null : <PersonalityByAttendance>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<PersonalityByAttendance>(<any>null);
  }

  /**
   * Get Detail Personality By Attendance
   * @param id id
   * @return successful operation
   */
  getPersonalityByAttendanceDetail(id: string): Promise<PersonalityByAttendance> {
    let url_ = this.baseUrl + '/personalityByAttendance/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPersonalityByAttendanceDetail(_response);
    });
  }

  protected processGetPersonalityByAttendanceDetail(response: Response): Promise<PersonalityByAttendance> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <PersonalityByAttendance>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<PersonalityByAttendance>(<any>null);
  }

  /**
   * Update Detail Personality By Attendance
   * @param id answerId
   * @param body (optional)
   * @return successful operation
   */
  updatePersonalityByAttendance(id: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/personalityByAttendance/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdatePersonalityByAttendance(_response);
    });
  }

  protected processUpdatePersonalityByAttendance(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Get All Attendance Detail By Attendance
   * @param operation (optional) operation
   * @param search (optional) search
   * @param filter (optional) filters
   * @param first (optional) number of records returned
   * @param sortBy (optional) sort field
   * @param before (optional) before token
   * @param after (optional) after token
   * @return successful operation
   */
  getAllAttendancee(
    operation: string | undefined,
    search: string | undefined,
    filter: any[] | undefined,
    first: number | undefined,
    sortBy: string | undefined,
    before: string | undefined,
    after: string | undefined,
  ): Promise<FindAttendanceResult> {
    let url_ = this.baseUrl + '/attendance?';
    if (operation === null) throw new Error("The parameter 'operation' cannot be null.");
    else if (operation !== undefined) url_ += 'operation=' + encodeURIComponent('' + operation) + '&';
    if (search === null) throw new Error("The parameter 'search' cannot be null.");
    else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
    if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
    else if (filter !== undefined)
      filter &&
        filter.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += 'filter[' + index + '].' + attr + '=' + encodeURIComponent('' + (<any>item)[attr]) + '&';
            }
        });
    if (first === null) throw new Error("The parameter 'first' cannot be null.");
    else if (first !== undefined) url_ += 'first=' + encodeURIComponent('' + first) + '&';
    if (sortBy === null) throw new Error("The parameter 'sortBy' cannot be null.");
    else if (sortBy !== undefined) url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (before === null) throw new Error("The parameter 'before' cannot be null.");
    else if (before !== undefined) url_ += 'before=' + encodeURIComponent('' + before) + '&';
    if (after === null) throw new Error("The parameter 'after' cannot be null.");
    else if (after !== undefined) url_ += 'after=' + encodeURIComponent('' + after) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAllAttendancee(_response);
    });
  }

  protected processGetAllAttendancee(response: Response): Promise<FindAttendanceResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 =
          _responseText === '' ? null : <FindAttendanceResult>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('unauthorize', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<FindAttendanceResult>(<any>null);
  }

  /**
   * Create Attendance
   * @param body (optional)
   * @return successful operation
   */
  createAttendance(body: any | undefined): Promise<Attendance> {
    let url_ = this.baseUrl + '/attendance';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateAttendance(_response);
    });
  }

  protected processCreateAttendance(response: Response): Promise<Attendance> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Attendance>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === '' ? null : <Attendance>JSON.parse(_responseText, this.jsonParseReviver);
        return result201;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Attendance>(<any>null);
  }

  /**
   * Get Attendance
   * @param id id
   * @return successful operation
   */
  getAttendance(id: string): Promise<Attendance> {
    let url_ = this.baseUrl + '/attendance/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_ = <RequestInit>{
      method: 'GET',
      headers: {
        Accept: 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAttendance(_response);
    });
  }

  protected processGetAttendance(response: Response): Promise<Attendance> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === '' ? null : <Attendance>JSON.parse(_responseText, this.jsonParseReviver);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<Attendance>(<any>null);
  }

  /**
   * Update Attendance
   * @param id answerId
   * @param body (optional)
   * @return successful operation
   */
  updateAttendance(id: string, body: any | undefined): Promise<void> {
    let url_ = this.baseUrl + '/attendance/{id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_ = <RequestInit>{
      body: content_,
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateAttendance(_response);
    });
  }

  protected processUpdateAttendance(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 201) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('bad request', status, _responseText, _headers);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException('Token is invalid or expired', status, _responseText, _headers);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        return throwException('internal server error', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException('An unexpected server error occurred.', status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(<any>null);
  }
}

export interface GetAllRolesResult {
  roles: Role[];
}

export interface CheckRoleNameExistResult {
  roleNameExist: boolean;
}

export interface FindPermissionsResult {}

export interface RegisterUserPayload {
  idToken: string;
  role: string;
  name: string;
  phoneNumber: string;
  email: string;
  gender: string;
  dob: number;
  password: string;
  avatar: string;
  address: string;
  country: string;
  timeZone: string;
  zipCode: string;
  appleId: string;
}

export interface FindRolesResult {
  data: Role[];
  before: string;
  after: string;
}

export interface ActivateRolePayload {
  operation: ActivateRolePayloadOperation;
}

export interface DeactivateRolePayload {
  operation: DeactivateRolePayloadOperation;
}

export interface UpdateRolePayload {
  operation: UpdateRolePayloadOperation;
  payload: Payload;
}

export interface Role {
  _id: string;
  name: string;
  description: string;
  isActive: any;
  permissions: string[];
}

export interface CreateRolePayload {
  name: string;
  description: string;
  permissions: string[];
}

export interface CheckEmailExistResult {
  emailExist: boolean;
  loginDetail: any;
}

export interface FindUsersResult {
  data: User[];
  before: string;
  after: string;
}

export interface FindAllUsersResult {
  data: User[];
}

export interface PermissionsResult {
  data: string[];
}

export interface FacebookLogin {
  uid: string;
  email: string;
  provider: FacebookLoginProvider;
}

export interface GoogleLogin {
  uid: string;
  email: string;
  provider: GoogleLoginProvider;
}

export interface PhoneLogin {
  phoneNo: string;
  provider: PhoneLoginProvider;
}

export interface EmailLogin {
  email: string;
  provider: EmailLoginProvider;
}

export interface User {
  _id: string;
  id: string;
  email: string;
  familyName: string;
  givenName: string;
  fullName: string;
  phoneNumber: string;
  phoneID: string;
  about: string;
  address: string;
  description: string;
  avatar: string;
  dob: number;
  language: Language;
  gender: string;
  zipCode: string;
  timeZone: string;
  images: string[];
  certificate: Certificate;
  categories: Categories[];
  teacherDescription: string;
  teachingMaterial: string;
  introductionVideo: string;
  deviceToken: any[];
  rating: number;
  loginDetail: any;
  roles: string[];
  completeSignUp: boolean;
  hourlyRate: number;
  campusId: string;
  isActive: boolean;
  createdAt: number;
  createdBy: number;
  favoriteTeachers: any[];
  favoriteClasses: any[];
}

export interface UpdateUserPayload {
  operation: UpdateUserPayloadOperation;
  payload: Payload2;
}

export interface ChangePasswordPayload {
  newPassword: string;
}

export interface UpdateProfilePayload {
  operation: UpdateProfilePayloadOperation;
  payload: Payload3;
}

export interface ActivateUserPayload {
  operation: ActivateUserPayloadOperation;
}

export interface DeactivateUserPayload {
  operation: DeactivateUserPayloadOperation;
}

export interface UpdateAvatarPayload {
  operation: UpdateAvatarPayloadOperation;
  data: Data;
}

export interface CreateUserPayload {
  email: string;
  password: string;
  roles: string[];
  familyName: string;
  givenName: string;
}

export interface SendResetPasswordCodeResponse {
  code: number;
  message: string;
}

export interface CheckPasswordResetCodeResponse {
  code: number;
  message: string;
}

export interface SendResetPasswordCodeBody {
  email: string;
}

export interface CheckPasswordResetCodeBody {
  email: string;
  code: string;
}

export interface ResetPasswordBody {
  email: string;
  code: string;
  password: string;
}

export interface ResetPasswordResponse {
  code: number;
  message: string;
}

export interface LogOutBody {
  id: string;
  deviceToken: string;
}

export interface LogOutResponse {
  code: number;
  message: string;
}

export interface FindCareerMatrixResult {
  data: CareerMatrix[];
  before: string;
  after: string;
}

export interface CareerMatrix {
  id: string;
  personality: string;
  career: string;
}

export interface CreateCareerMatrixPayload {
  personality: string;
  career: string;
}

export interface UpdateCareerMatrixPayload {
  personality: string;
  career: string;
}

export interface Career {
  id: string;
  title: string;
  description: string;
}

export interface FindCareerResult {
  data: Career[];
  before: string;
  after: string;
}

export interface CreateCareerPayload {
  title: string;
  description: string;
}

export interface UpdateCareerPayload {
  operation: string;
  payload: Payload4;
}

export interface CreateNotificationPayload {
  title: string;
  data: any;
  notificationType: string;
  from: string;
  to: string;
  notifyAt: number;
  channel: string;
  read: boolean;
}

export interface UpdateNotificationPayload {
  id: string;
  _id: string;
  title: string;
  data: any;
  notificationType: string;
  from: string;
  to: string;
  notifyAt: number;
  channel: string;
  read: boolean;
}

export interface FindNotificationsResult {
  data: Notification[];
  before: string;
  after: string;
}

export interface Notification {
  id: string;
  _id: string;
  title: string;
  data: any;
  notificationType: string;
  from: string;
  to: string;
  notifyAt: number;
  channel: string;
  read: boolean;
  createdAt: number;
  updatedAt: number;
}

export interface FindAttendanceResult {
  data: Attendance[];
  before: string;
  after: string;
}

export interface Attendance {
  id: string;
  _id: string;
  user: string;
  testPack: string;
  firstPersonality: string;
  firstPersonalityTotalMark: number;
  secondPersonality: string;
  secondPersonalityTotalMark: number;
  thirdPersonality: string;
  thirdPersonalityTotalMark: number;
  isFinished: boolean;
  createdAt: number;
  updatedAt: number;
}

export interface UpdateAttendancePayload {
  operation: string;
  payload: Payload5;
}

export interface CreateAttendancePayload {
  user: string;
  testPack: string;
  firstPersonality: string;
  firstPersonalityTotalMark: number;
  secondPersonality: string;
  secondPersonalityTotalMark: number;
  thirdPersonality: string;
  thirdPersonalityTotalMark: number;
  isFinished: boolean;
}

export interface FindPersonalityByAttendanceDetailResult {
  data: PersonalityByAttendance[];
  before: string;
  after: string;
}

export interface PersonalityByAttendance {
  id: string;
  _id: string;
  user: string;
  attendance: string;
  personality: string;
  totalMark: number;
  createdAt: number;
  updatedAt: number;
}

export interface UpdatePersonalityByAttendancePayload {
  operation: string;
  payload: Payload6;
}

export interface CreatePersonalityByAttendancePayload {
  user: string;
  attendance: string;
  personality: string;
  totalMark: number;
}

export interface CreateAnswerByAttendancePayload {
  user: string;
  attendance: string;
  question: number;
  personality: string;
  answer: string;
  mark: number;
}

export interface UpdateAnswerDetailByAttendancePayload {
  operation: string;
  payload: Payload7;
}

export interface FindAnswerDetailResult {
  data: AnswerDetailByAttendance[];
  before: string;
  after: string;
}

export interface AnswerDetailByAttendance {
  id: string;
  _id: string;
  user: string;
  attendance: string;
  question: number;
  personality: string;
  answer: string;
  mark: number;
  createdAt: number;
  updatedAt: number;
}

export interface FindAnswerResult {
  data: Answer[];
}

export interface Answer {
  id: string;
  _id: string;
  question: string;
  personality: string;
  order: number;
  content: string;
  mark: number;
  createdAt: number;
  updatedAt: number;
}

export interface CreateAnswerPayload {
  question: string;
  personality: string;
  order: number;
  content: string;
  mark: number;
}

export interface UpdateAnswerPayload {
  operation: string;
  payload: Payload8;
}

export interface FindTestPackResult {
  data: TestPack[];
  before: string;
  after: string;
}

export interface TestPack {
  id: string;
  _id: string;
  title: string;
  type: string;
  version: string;
  createdAt: number;
  updatedAt: number;
}

export interface CreateTestPackPayload {
  title: string;
  type: string;
  version: string;
}

export interface UpdateTestPackPayload {
  operation: string;
  payload: Payload9;
}

export interface FindSectionResult {
  data: SectionByPack[];
  before: string;
  after: string;
}

export interface CreatePersonalityPayload {
  testPack: string;
  title: string;
  description: string;
  code: string;
}

export interface UpdatePersonalityPayload {
  operation: string;
  payload: Payload10;
}

export interface FindPersonalityResult {
  data: PersonalityByPack[];
  before: string;
  after: string;
}

export interface CreateSectionPayload {
  testPack: string;
  title: string;
}

export interface UpdateSectionPayload {
  operation: string;
  payload: Payload11;
}

export interface SectionByPack {
  id: string;
  _id: string;
  testPack: string;
  title: string;
}

export interface PersonalityByPack {
  id: string;
  _id: string;
  testPack: string;
  title: string;
  code: string;
  description: string;
}

export interface FindQuestionResult {
  data: Question[];
  before: string;
  after: string;
}

export interface Question {
  id: string;
  _id: string;
  content: string;
  testPack: TestPack2;
  section: Section;
  personality: Personality;
  createdAt: number;
  updatedAt: number;
}

export interface CreateQuestionPayload {
  content: string;
  testPack: string;
  section: string;
  personality: string;
}

export interface UpdateQuestionPayload {
  operation: string;
  payload: Payload12;
}

export interface Availability {
  timeZone: number;
  timeList: number[];
  weekDay: number[];
}

export interface Anonymous {
  data: Data2;
}

export enum ActivateRolePayloadOperation {
  Activate = 'activate',
}

export enum DeactivateRolePayloadOperation {
  Deactivate = 'deactivate',
}

export enum UpdateRolePayloadOperation {
  UpdateDetail = 'updateDetail',
}

export interface Payload {
  name: string;
  description: string;
  permissions: string[];
}

export enum FacebookLoginProvider {
  Facebook = 'facebook',
}

export enum GoogleLoginProvider {
  Google = 'google',
}

export enum PhoneLoginProvider {
  Phone = 'phone',
}

export enum EmailLoginProvider {
  Email = 'email',
}

export interface Language {
  name: string;
  shortCode: string;
}

export interface Certificate {
  title: string;
  subject: string;
  from: number;
  to: number;
}

export interface Categories {
  _id: string;
  title: string;
}

export enum UpdateUserPayloadOperation {
  UpdateDetail = 'updateDetail',
}

export interface Payload2 {
  roles: string[];
  familyName: string;
  givenName: string;
  fullName: string;
  avatar: string;
  email: string;
  favoriteTeachers: any[];
  favoriteClasses: any[];
}

export enum UpdateProfilePayloadOperation {
  UpdateDetail = 'updateDetail',
}

export interface Payload3 {
  familyName: string;
  givenName: string;
  phoneNo: string;
  email: string;
  address: string;
  description: string;
}

export enum ActivateUserPayloadOperation {
  Activate = 'activate',
}

export enum DeactivateUserPayloadOperation {
  Deactivate = 'deactivate',
}

export enum UpdateAvatarPayloadOperation {
  UpdateAvatar = 'updateAvatar',
}

export interface Data {
  avatarUrl: string;
}

export interface Payload4 {
  title: string;
  description: string;
}

export interface Payload5 {
  user: string;
  testPack: string;
  firstPersonality: string;
  firstPersonalityTotalMark: number;
  secondPersonality: string;
  secondPersonalityTotalMark: number;
  thirdPersonality: string;
  thirdPersonalityTotalMark: number;
  isFinished: boolean;
}

export interface Payload6 {
  user: string;
  attendance: string;
  personality: string;
  totalMark: number;
}

export interface Payload7 {
  user: string;
  attendance: string;
  question: number;
  personality: string;
  answer: string;
  mark: number;
}

export interface Payload8 {
  question: string;
  personality: string;
  order: number;
  content: string;
  mark: number;
}

export interface Payload9 {
  title: string;
  type: string;
  version: string;
}

export interface Payload10 {
  testPack: string;
  title: string;
  description: string;
  code: string;
}

export interface Payload11 {
  testPack: string;
  title: string;
}

export interface TestPack2 {
  id: string;
  _id: string;
}

export interface Section {
  id: string;
  _id: string;
}

export interface Personality {
  id: string;
  _id: string;
}

export interface Payload12 {
  content: string;
  testPack: string;
  section: string;
  personality: string;
}

export interface Data2 {
  totalClass: number;
  totalStudent: number;
  joinedClass: number;
  joinedLesson: number;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
